{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { useSocket } from './useSocket.js';\nexport const useRealtimeData = dataType => {\n  _s();\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const {\n    socket,\n    isConnected,\n    addEventListener,\n    removeEventListener\n  } = useSocket();\n  const API_BASE_URL = 'http://localhost:3001/api';\n\n  // Define event names based on data type\n  const eventConfig = {\n    announcements: {\n      endpoint: 'announcements',\n      created: 'announcement_created',\n      updated: 'announcement_updated',\n      deleted: 'announcement_deleted'\n    },\n    schools: {\n      endpoint: 'schools',\n      created: 'school_created',\n      updated: 'school_updated',\n      deleted: 'school_deleted'\n    }\n  };\n  const config = eventConfig[dataType];\n  if (!config) {\n    throw new Error(`Unsupported data type: ${dataType}`);\n  }\n  const fetchData = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      console.log(`ðŸ“¡ Fetching ${dataType} from API...`);\n      const response = await fetch(`${API_BASE_URL}/${config.endpoint}`);\n      const result = await response.json();\n      if (result.success) {\n        console.log(`âœ… Loaded ${result.data.length} ${dataType}`);\n        setData(result.data);\n      } else {\n        throw new Error(result.message || `Failed to fetch ${dataType}`);\n      }\n    } catch (err) {\n      console.error(`Error fetching ${dataType}:`, err);\n      setError(`Failed to load ${dataType}. Please try again later.`);\n      setData([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [dataType, config.endpoint]);\n\n  // Set up real-time event listeners\n  useEffect(() => {\n    if (!socket || !isConnected) return;\n    console.log(`ðŸ”Œ Setting up real-time listeners for ${dataType}...`);\n    const handleCreated = newItem => {\n      console.log(`âž• New ${dataType} received:`, newItem);\n      setData(prev => [newItem, ...prev]);\n    };\n    const handleUpdated = updatedItem => {\n      console.log(`âœï¸ ${dataType} updated:`, updatedItem);\n      setData(prev => prev.map(item => item._id === updatedItem._id ? updatedItem : item));\n    };\n    const handleDeleted = deletionData => {\n      console.log(`ðŸ—‘ï¸ ${dataType} deleted:`, deletionData.id);\n      setData(prev => prev.filter(item => item._id !== deletionData.id));\n    };\n\n    // Add event listeners\n    addEventListener(config.created, handleCreated);\n    addEventListener(config.updated, handleUpdated);\n    addEventListener(config.deleted, handleDeleted);\n\n    // Clean up event listeners\n    return () => {\n      console.log(`ðŸ”Œ Cleaning up ${dataType} listeners...`);\n      removeEventListener(config.created, handleCreated);\n      removeEventListener(config.updated, handleUpdated);\n      removeEventListener(config.deleted, handleDeleted);\n    };\n  }, [socket, isConnected, dataType, config, addEventListener, removeEventListener]);\n\n  // Fetch data on mount and when connection is restored\n  useEffect(() => {\n    fetchData();\n  }, [fetchData, isConnected]);\n\n  // Refetch data when connection is restored\n  useEffect(() => {\n    if (isConnected) {\n      console.log(`ðŸ”„ Connection restored, refetching ${dataType}...`);\n      fetchData();\n    }\n  }, [isConnected, fetchData, dataType]);\n  const refetch = useCallback(() => {\n    console.log(`ðŸ”„ Manual refetch triggered for ${dataType}`);\n    fetchData();\n  }, [fetchData, dataType]);\n  return {\n    data,\n    loading,\n    error,\n    refetch,\n    isConnected\n  };\n};\n_s(useRealtimeData, \"OLDFsAfUsW58jrvHDeJjHPKTVTU=\", false, function () {\n  return [useSocket];\n});","map":{"version":3,"names":["useState","useEffect","useCallback","useSocket","useRealtimeData","dataType","_s","data","setData","loading","setLoading","error","setError","socket","isConnected","addEventListener","removeEventListener","API_BASE_URL","eventConfig","announcements","endpoint","created","updated","deleted","schools","config","Error","fetchData","console","log","response","fetch","result","json","success","length","message","err","handleCreated","newItem","prev","handleUpdated","updatedItem","map","item","_id","handleDeleted","deletionData","id","filter","refetch"],"sources":["C:/jbmmsi/client/src/hooks/useRealtimeData.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\nimport { useSocket } from './useSocket.js';\r\n\r\nexport const useRealtimeData = (dataType) => {\r\n  const [data, setData] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  const { socket, isConnected, addEventListener, removeEventListener } = useSocket();\r\n\r\n  const API_BASE_URL = 'http://localhost:3001/api';\r\n\r\n  // Define event names based on data type\r\n  const eventConfig = {\r\n    announcements: {\r\n      endpoint: 'announcements',\r\n      created: 'announcement_created',\r\n      updated: 'announcement_updated',\r\n      deleted: 'announcement_deleted'\r\n    },\r\n    schools: {\r\n      endpoint: 'schools',\r\n      created: 'school_created',\r\n      updated: 'school_updated',\r\n      deleted: 'school_deleted'\r\n    }\r\n  };\r\n\r\n  const config = eventConfig[dataType];\r\n\r\n  if (!config) {\r\n    throw new Error(`Unsupported data type: ${dataType}`);\r\n  }\r\n\r\n  const fetchData = useCallback(async () => {\r\n    try {\r\n      setLoading(true);\r\n      setError(null);\r\n      console.log(`ðŸ“¡ Fetching ${dataType} from API...`);\r\n      \r\n      const response = await fetch(`${API_BASE_URL}/${config.endpoint}`);\r\n      const result = await response.json();\r\n      \r\n      if (result.success) {\r\n        console.log(`âœ… Loaded ${result.data.length} ${dataType}`);\r\n        setData(result.data);\r\n      } else {\r\n        throw new Error(result.message || `Failed to fetch ${dataType}`);\r\n      }\r\n    } catch (err) {\r\n      console.error(`Error fetching ${dataType}:`, err);\r\n      setError(`Failed to load ${dataType}. Please try again later.`);\r\n      setData([]);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [dataType, config.endpoint]);\r\n\r\n  // Set up real-time event listeners\r\n  useEffect(() => {\r\n    if (!socket || !isConnected) return;\r\n\r\n    console.log(`ðŸ”Œ Setting up real-time listeners for ${dataType}...`);\r\n\r\n    const handleCreated = (newItem) => {\r\n      console.log(`âž• New ${dataType} received:`, newItem);\r\n      setData(prev => [newItem, ...prev]);\r\n    };\r\n\r\n    const handleUpdated = (updatedItem) => {\r\n      console.log(`âœï¸ ${dataType} updated:`, updatedItem);\r\n      setData(prev => \r\n        prev.map(item => \r\n          item._id === updatedItem._id ? updatedItem : item\r\n        )\r\n      );\r\n    };\r\n\r\n    const handleDeleted = (deletionData) => {\r\n      console.log(`ðŸ—‘ï¸ ${dataType} deleted:`, deletionData.id);\r\n      setData(prev => \r\n        prev.filter(item => item._id !== deletionData.id)\r\n      );\r\n    };\r\n\r\n    // Add event listeners\r\n    addEventListener(config.created, handleCreated);\r\n    addEventListener(config.updated, handleUpdated);\r\n    addEventListener(config.deleted, handleDeleted);\r\n\r\n    // Clean up event listeners\r\n    return () => {\r\n      console.log(`ðŸ”Œ Cleaning up ${dataType} listeners...`);\r\n      removeEventListener(config.created, handleCreated);\r\n      removeEventListener(config.updated, handleUpdated);\r\n      removeEventListener(config.deleted, handleDeleted);\r\n    };\r\n  }, [socket, isConnected, dataType, config, addEventListener, removeEventListener]);\r\n\r\n  // Fetch data on mount and when connection is restored\r\n  useEffect(() => {\r\n    fetchData();\r\n  }, [fetchData, isConnected]);\r\n\r\n  // Refetch data when connection is restored\r\n  useEffect(() => {\r\n    if (isConnected) {\r\n      console.log(`ðŸ”„ Connection restored, refetching ${dataType}...`);\r\n      fetchData();\r\n    }\r\n  }, [isConnected, fetchData, dataType]);\r\n\r\n  const refetch = useCallback(() => {\r\n    console.log(`ðŸ”„ Manual refetch triggered for ${dataType}`);\r\n    fetchData();\r\n  }, [fetchData, dataType]);\r\n\r\n  return {\r\n    data,\r\n    loading,\r\n    error,\r\n    refetch,\r\n    isConnected\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}